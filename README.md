
## 🎮 프로젝트 소개: BeatSlime: 2D Clicker Game

**BeatSlime**은 플레이어가 오직 클릭을 통해 몬스터를 처치하고, 획득한 골드로 캐릭터와 무기를 성장시키는 2D 클리커 게임입니다. 직관적인 게임 플레이와 성장 시스템을 통해 누구나 쉽게 즐길 수 있도록 제작되었습니다.

----------

## 🧑‍🤝‍🧑 팀원 소개

-   **[팀원 1 김성민]**:  플레이어 능력치 및 업그레이드, 클릭 이벤트 후반부 담당
    
-   **[팀원 2 심재환]**: 사운드, 게임매니저, 스테이지, 저장, 재화 담당 
    
-   **[팀원 3 이도현]**: 클릭 이벤트 기초 작업, 무기 업그레이드 담당

-    **[팀원 3 황상욱]**: 적 생성 및 애니메이션 관리, 체력바와 입힌 데미지 표기 담당


----------

## 🕹️ 주요 시스템 및 기능

-   **클릭 기반 전투**: 화면을 탭하여 적에게 직접 피해를 입히는 게임의 핵심 기능입니다. 무기 및 치명타 데미지에 따라 데미지가 결정됩니다.
    
-   **스탯 업그레이드**: 획득한 골드로 치명타 데미지, 자동 공격 속도, 골드 보너스 등 핵심 능력치를 영구적으로 강화합니다. 클릭이 주가 되는 게임이지만, 일정 수준 업그레이드 시 보조적인 자동 공격을 통해 효율을 높일 수 있습니다
    
-   **무기 강화 시스템**: 현재 장착한 무기를 강화하여 공격력과 치명타 확률을 증가시킵니다.
    
-   **스테이지 진행**: 일정 조건을 만족하면 새로운 스테이지로 이동하여 더 강력한 몬스터를 만나고 더 많은 보상을 얻을 수 있습니다.
    
-   **데이터 영구 저장**: 게임 진행 상황은 JSON 파일로 저장되어 언제든지 이어서 플레이할 수 있습니다.
    

----------

## 🎬 시연 영상

    

----------

## 💻 기술 스택

-   **엔진**: Unity 2022.3.17f1
    
-   **언어**: C#
    
-   **주요 라이브러리/에셋**:

-- **Unity Input System**: **클릭 이벤트 처리**를 위해 사용, 기존 `Update` 방식의 비효율성을 개선
    
--  **TextMeshPro**: **UI 텍스트 출력**을 위해 사용, 뛰어난 렌더링 품질과 효율성 제공
  
        
       

----------
##  ®이번 작업중 괜찮았던 코드 리뷰
 
 **김성민**

**`Input System`으로의 전환 ⌨️**

<img width="516" height="503" alt="3" src="https://github.com/user-attachments/assets/fb3bc52f-a58d-4989-b8ff-238d7409d4d6" />

-   **장점**:
    -   **성능 최적화**: `Update`는 매 프레임마다 입력 상태를 확인하는 '폴링(Polling)' 방식이라 불필요한 연산이 많습니다. 반면, `Input System`은 클릭 같은 **이벤트가 발생할 때만** 함수를 호출하는 '이벤트 기반(Event-driven)' 방식이라 CPU 자원을 훨씬 효율적으로 사용합니다.
    -   **관리의 용이성**: 마우스, 키보드, 터치, 게임패드 등 다양한 입력 장치를 통일된 방식으로 관리할 수 있게 됩니다. 나중에 다른 플랫폼으로 게임을 포팅하거나 새로운 입력 방식을 추가할 때 코드를 거의 수정할 필요가 없습니다.
----
**이도현**

<img width="644" height="319" alt="image (1)" src="https://github.com/user-attachments/assets/d4ba50db-3551-4f55-b533-3bb33a4a429d" />

무기별 베이스 스탯을 스크럽 터블 데이터로 만들어 두고 베이스 스탯은 나누기 연산으로 강화 단계는 나머지 연산으로 다음 무기로 넘어갈 때 베이스 스탯으로 정보들을 업데이트 하는 코드들이 인상 깊었다

-----
**황상욱**

<img width="644" height="319" alt="image (2)" src="https://github.com/user-attachments/assets/818d9c3f-84a3-4b4a-8861-eea99d6d5569" />

체력바와 데미지를 코루틴을 통해서 구현한 것이 마음에 들었습니다. 코루틴 사용법에 감을 잡을 수 있었습니다.

-----
**심재환**
    
스테이지 관련 ui와 게임 설정에 대한 ui를 제작하는과정에서
addlistner를 통해 함수설계와 코드 내에서 바로 버튼을 연결하였습니다. 특히 버튼을 많이 사용하는 스테이지 관련 ui작업했을 때 효율적이었습니다.
    
<img width="644" height="319" alt="image (4)" src="https://github.com/user-attachments/assets/47e186b1-6ea9-4deb-b50a-7d08a33984a7" />

    
클래스를 활용해서 값을 저장하는 방식을 처음 해보았습니다. 데이터 저장에도 좋았고 이후 
    
<img width="644" height="319" alt="image (5)" src="https://github.com/user-attachments/assets/f6e9b5bf-a3da-4806-9d71-d130eaeb2ad9" />

    
스테이지를 만드는 과정에서 여러 조건을 사용해야했습니다. 그때 저장 및 클래스로써 데이터를 모아두었기에 여러 조건이 맞아야 활성화되는 로직을 편리하게 만들어갈 수 있었습니다.

<img width="644" height="319" alt="image (6)" src="https://github.com/user-attachments/assets/3c774248-0847-4c75-88fe-7b44b8d55a76" />


## ⚠️ 트러블 슈팅
**김성민**

### `private` 변수 접근 오류 ⚠️

`[SerializeField] private PlayerData player;`

`private` 변수는 선언된 클래스인 `GameManager` 내부에서만 접근할 수 있습니다. 그래서 `UpgradeManager` 같은 다른 스크립트에서 `GameManager.Instance.player`로 직접 접근하면 "**보호 수준 때문에 액세스할 수 없습니다**"라는 오류가 발생했습니다.

이 문제를 해결하는 가장 간단한 방법은 `private`을 `public`으로 바꾸는 거지만, 이는 좋은 코딩 방식이 아니라고 합니다.

----------

### 해결책: 프로퍼티를 사용한 캡슐화 ✅

`public PlayerData Player { get { return player; } }`

이 코드는 `player` 변수 자체는 `private` 상태로 그대로 둡니다. 대신 `Player`라는 **Property**를 만들어주는 겁니다.

-   `get` 접근자만 있어서 다른 스크립트들은 `player`의 데이터를 **읽기만 할 수 있고, 함부로 직접 변경할 수는 없어요.** `UpgradeManager`가 `GameManager.Instance.Player.gold`를 읽는 것이 바로 이 과정을 통해 이루어집니다.
    
-   `UpgradeManager`가 `player` 데이터의 값을 바꿔야 할 때는 `GameManager`가 제공하는 `TrySpendGold` 같은 **메서드를 사용해야 합니다.**
    

----------

### **왜 `public`이 아니라 프로퍼티를 사용해야 하는가?**

1.  **데이터 보호**: `public`으로 변수를 직접 노출하면 어떤 스크립트든 값을 마음대로 바꿀 수 있어서 예상치 못한 버그가 생기기 쉽습니다. 프로퍼티는 외부 접근을 읽기로만 제한해서 데이터의 **무결성**을 지킬 수 있습니다.
    
2.  **안전한 로직**: `GameManager`는 골드 소비 같은 중요한 로직을 직접 관리해야 합니다. 만약 `player.gold`가 `public`이라면, 다른 스크립트가 `GameManager.Instance.player.gold -= 100;`처럼 직접 값을 조작해 재화 부족 체크 같은 핵심 로직을 건너뛰는 버그를 초래할 수 있습니다. 프로퍼티를 사용하면 이런 위험을 막을 수 있습니다.
    
3.  **유지보수 용이성**: 만약 나중에 `PlayerData` 구조를 변경해야 할 때, 프로퍼티를 사용하면 `GameManager` 내부 로직만 수정하면 됩니다. `public` 변수를 사용했다면 해당 변수에 접근하는 모든 스크립트를 찾아 일일이 수정해야 하는 번거로움이 생깁니다.
    

결론적으로, `public` 대신 프로퍼티를 사용하는 것은 **안정성, 유지보수, 데이터 보호**라는 세 가지 핵심 장점을 제공하는 코딩 방법입니다.

----

### ⚠️ 문제: 하나의 메서드가 너무 많은 일을 한다

이전 코드의 `UpdateUpgradeUI()` 메서드는 이름과 달리 단순히 UI만 업데이트하지 않았습니다.

-   **UI 업데이트:** 레벨, 값, 비용 텍스트를 변경하고 색깔을 칠했습니다.
    
-   **데이터 업데이트:** `currentValue`와 `nextLevelCost`를 계산하고, 그 값들을 `GameManager`에 저장했습니다.
    

이렇게 한 메서드가 여러 역할을 맡게 되면, 나중에 코드를 수정하거나 버그를 찾기가 매우 어려워집니다. 예를 들어, UI 디자인을 바꿔야 할 때도 데이터 로직이 섞여 있어서 실수로 중요한 부분을 건드릴 위험이 있었습니다.

----------

### ✅ 해결책: 역할별로 메서드 분리하기
<img width="713" height="387" alt="1" src="https://github.com/user-attachments/assets/f0e89e5b-fc57-4247-95ab-9ec552c95f5f" />
<img width="687" height="410" alt="2" src="https://github.com/user-attachments/assets/763884a3-1717-4c89-9b8f-6b67da655bfa" />

해결책은 **단일 책임 원칙**에 따라 각 메서드가 하나의 역할만 하도록 분리하는 것입니다.

-   **`UpdateUpgradeData()` 메서드 (데이터 전담):** 이 메서드는 UI와 전혀 상관없이 **순수하게 데이터를 처리**하는 역할만 합니다.
    
    -   새로운 능력치 값과 비용을 계산합니다.
        
    -   계산된 값을 `GameManager`에 저장합니다.
        
    -   이 메서드는 `private`으로 설정하여 다른 스크립트가 함부로 접근해 데이터 로직을 망가뜨리지 못하게 막았습니다.
        
-   **`UpdateUpgradeUI()` 메서드 (UI 전담):** 이 메서드는 **오직 화면에 보이는 부분만** 관리합니다.
    
    -   `UpdateUpgradeData()`에서 계산된 값을 가져와서 `levelText`, `valueText`, `costText` 같은 UI 요소를 업데이트합니다.
        
    -   골드 여부에 따라 비용 텍스트의 색상을 변경합니다.
        

 `OnClickUpgradeButton()` 같은 메서드가 호출되면, **데이터를 먼저 업데이트(`UpdateUpgradeData()`)하고, 그 다음에 UI를 업데이트(`UpdateUpgradeUI()`)**하는 순서로 코드가 실행됩니다.

결론적으로, 이 **코드를 더 체계적으로 만들고, 버그를 줄이며, 나중에 유지보수와 기능 확장을 훨씬 쉽게** 만드는 방법입니다.



### **문제점: `Update` 메서드의 비효율성**

기존 `Update` 메서드는 매 프레임마다 `if (Input.GetMouseButtonDown(0))`와 같이 **지속적으로 입력 상태를 확인**하는 방식으로 작동합니다.

-   **불필요한 연산**: 사용자가 클릭을 하지 않더라도, 게임이 실행되는 매 순간마다 입력 상태를 확인하는 연산을 반복합니다. 이는 CPU 자원을 낭비하는 비효율적인 방식입니다.
    
-   **성능 저하**: 특히 클릭 수가 많은 방치형 게임이나, 모바일 환경에서는 이런 불필요한 폴링 연산이 배터리 소모와 성능 저하의 원인이 됩니다.
    

----------

### **해결책: `Input System`의 이벤트 기반 방식**

`Input System`은 **이벤트 기반(Event-driven)**으로 동작하여, 오직 특정 입력(예: 마우스 클릭, 키보드 누르기)이 발생했을 때만 미리 정의된 함수를 호출합니다.

-   **자원 절약**: `playerControls.Player.Attack.performed += OnAttack;` 코드처럼, "Attack" 액션이 `performed`(수행)되는 **이벤트가 발생할 때만** `OnAttack` 함수를 실행합니다. 입력이 없을 때는 아무런 연산도 하지 않아, `Update` 메서드보다 훨씬 효율적으로 CPU 자원을 관리합니다.
    
-   **유연성**: 마우스, 키보드, 게임패드, 터치 등 다양한 입력 장치를 통일된 방식으로 처리할 수 있어 코드가 깔끔해집니다. 별도의 코드를 추가하지 않고도 다른 장치에 맞는 입력을 쉽게 추가할 수 있어 게임의 확장성이 높아집니다.

결론적으로, `Update`에서 `Input System`으로 변경한 것은 **게임의 성능을 최적화하고, 효율성을 높이며, 다양한 플랫폼에 대응하기 위한** 방법입니다.

----
**이도현**
무기 30개, 강화단계 6개로 데이터를 관리하려다보니 스크럽터블데이터를 180개를 만들어야하는 상황이 왔다. 무기 30개의 베이스 스탯으로 30개를 두고 강화 단계별 공격력, 치명타확률을 추가하는 방식으로 해결했다.

무기 도감 부분에서 웨폰의 정보들을 가져와서 웨폰이 해금될때마다 도감 갱신되게 하려고 했는데 잘 안됐다. t:weapon으로 웨폰의 현 상황 확인을 해보니 메인으로 만들어둔 웨폰이 아닌 슬롯에 복사한 웨폰들이 강화할때마다 업데이트 되고있었다.

그래서 복사한 웨폰들의 정보를 웨폰콜렉션에서 가져와서 도감에 적용했더니 해결되었다.
-----
**심재환**
게임매니저, ui매니저, 스테이지 매니저 등 매니저를 많이 사용하게 됐는데 만들때마다 instance, static 작업을 하게 됐다. 제너릭을 다음번에는 적극활용해볼 예정이다.

스크립터블 오브젝트

방치형 장르로 만들면서 무기 종류도 다양했고 그에 따라 스테이지 종류도 다양해졌다.

처음 스크립터블 오브젝트를 사용해서 공부하는 느낌도 들었다.

하지만 데이터가 방대해졌을 때 휴먼이슈가 자주 발생했다.
<img width="2880" height="1800" alt="image (3)" src="https://github.com/user-attachments/assets/6918d370-9609-4c1c-80d7-c73ac3556176" />

---------
**황상욱**
슬라임을 재생성 하는 과정을 처리 할 때 슬라임 프리팹을 여러 종류를 만들어서 생성하였으나, 각자의 데이터를 코드 내부에서 부여하는 방식으로 제작하였다.

-----

